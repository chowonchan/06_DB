[JOIN]

하나 이상의 테이블에서 데이터를 조회하기 위해 사용하고 수행 결과는 
하나의 Result Set으로 나옴

한행씩 한행씩 비교해 가면서 같은 결과 끼리 붙임

[1.내부 조인(INNER JOIN)]
    1) 연결에 사용할 두 컬럼명이 다른 경우

      -- EMPLOYEE 테이블, DEPARTMENT 테이블을 참조하여
      -- 사번, 이름, 부서코드, 부서명 조회

      -- EMPLOYEE 테이블에 DEPT_CODE컬럼과 DEPARTMENT 테이블에 DEPT_ID 컬럼은 
      -- 서로 같은 부서 코드를 나타낸다.
      --> 이를 통해 두 테이블이 관계가 있음을 알고 조인을 통해 데이터 추출이 가능.

      -- ANSI
      -- 연결에 사용할 컬럼명이 다른 경우 ON()을 사용

      SELECT EMP_ID, EMP_NAME, DEPT_CODE,DEPT_ID, DEPT_TITLE
      FROM EMPLOYEE
      JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

      --> DEPT_CODE, DEPT_ID가 일치하는 행끼리 한 행으로 합쳐짐
        --> 단, 일치하는 값이 없을 경우 JOIN 과에서 제외
          --> == INNER JOIN


[2.외부 조인(OUTER JOIN)]

-- 두 테이블의 지정하는 컬럼값이 일치하지 않는 행도 조인에 포함을 시킴
-->  *반드시 OUTER JOIN임을 명시해야 한다.

    1) LEFT [OUTER] JOIN  : 합치기에 사용한 두 테이블 중 왼편에 기술된 테이블의 
      -- 컬럼 수를 기준으로 JOIN

        -- ANSI 표준
        SELECT EMP_NAME, DEPT_TITLE
        FROM EMPLOYEE
        LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);
        -- NULL 값을 가진 하동운 , 이오리 도 포함 시켜서 23행 조회


        -- 오라클 구문(+)
        SELECT EMP_NAME, DEPT_TITLE
        FROM EMPLOYEE, DEPARTMENT
        WHERE DEPT_CODE = DEPT_ID(+);


    2) RIGHT [OUTER] JOIN : 합치기에 사용한 두 테이블 중 
      -- 오른편에 기술된 테이블의  컬럼 수를 기준으로 JOIN
      -- ANSI 표준
      SELECT EMP_NAME, DEPT_TITLE
      FROM EMPLOYEE
      RIGHT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);
      -- INNER JOIN 결과에 포함되지 않았던
      -- DEPARTMENT의 D3, D4, D7도 결과에 포함

      -- 오라클 구문
      SELECT EMP_NAME, DEPT_TITLE
      FROM EMPLOYEE ,DEPARTMENT
      WHERE DEPT_CODE(+) = DEPT_ID;


    3) FULL [OUTER] JOIN   : 합치기에 사용한 두 테이블이 가진 모든 행을 결과에 포함
      -- ** 오라클 구문은 FULL OUTER JOIN을 사용 못함

      -- ANSI 표준
      SELECT EMP_NAME, DEPT_TITLE
      FROM EMPLOYEE
      FULL JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

      -- INNER JOIN 결과에 포함되지 못했던
      -- EMPLOYEE 테이블의 하동운, 이오리
      -- DEPARTMENT 테이블의 D3, D4, D7
      -- 모두를 JOIN 결과에 포함 시켜라
      -- == LEFT UNION (합집합) RIGHT와 같은 결과


   [3.교차 조인(CROSS JOIN == CARTESIAN PRODUCT)]
    --  조인되는 테이블의 각 행들이 모두 매핑된 데이터가 검색되는 방법(곱집합)

    --> 직접 사용 보단 SELF JOIN의 실패 결과로 보여지는 모습이다!
    -- 라고 알아두는게 좋음

    SELECT EMP_ID, EMP_NAME, DEPT_TITLE
    FROM EMPLOYEE -- 23행
    CROSS JOIN DEPARTMENT -- 9행   -> 23 x 9 = 207행 전체 조회
    ORDER BY EMP_NAME, DEPT_CODE;


  [4. 비등가 조인(NON EQUAL JOIN)]

    -- '='(등호)를 사용하지 않는 조인문
    --  지정한 컬럼 값이 일치하는 경우가 아닌, 값의 범위에 포함되는 행들을 연결하는 방식

    -- 사원의 급여가
    -- SAL_LEVEL 에 작성된 최소(MIN_SAL) ~ 최대(MAX_SAL)
    -- 범위의 급여가 맞을 때만 결과에 포함하겠다는 JOIN

    --> 사원이 자신의 급여 레벨이 맞는 돈을 잘받고 있는지 확인

    SELECT 
        E.EMP_NAME,  
        E.SAL_LEVEL, 
        E.SALARY, 
        S.MIN_SAL, 
        S.MAX_SAL
    FROM EMPLOYEE E
    JOIN SAL_GRADE S ON (E.SALARY BETWEEN S.MIN_SAL AND S.MAX_SAL);


  [5. 자체 조인(SELF JOIN)]

    -- 같은 테이블을 조인.
    -- 자기 자신과 조인을 맺음
    --> 똑같은 테이블이 2개 있다고 생각하면 쉽다!!

    -- EMPLOYEE 테이블에서
    -- 모든 사원의 이름, 사수 번호(MANAGER_ID), 사수 이름 조회

    -- ANSI 표준

    SELECT 
        E.EMP_NAME 사원이름, 
        NVL(E.MANAGER_ID, '없음') 사수번호, 
        NVL(M.EMP_NAME	, '없음') 사수명
    FROM EMPLOYEE E
    LEFT JOIN EMPLOYEE M ON(E.MANAGER_ID = M.EMP_ID);


     [6. 자연 조인(NATURAL JOIN)]
      -- 동일한 타입과 이름을 가진 컬럼이 있는 테이블 간의 조인을 간단히 표현하는 방법
      -- 반드시 두 테이블 간의 동일한 컬럼명, 타입을 가진 컬럼이 필요
      --> 없을 경우 교차조인이 됨.

      SELECT EMP_NAME, JOB_CODE, JOB_NAME
      FROM EMPLOYEE
      JOIN JOB USING(JOB_CODE);

      -- NATURAL JOIN

      SELECT EMP_NAME, JOB_CODE, JOB_NAME
      FROM EMPLOYEE
      NATURAL JOIN JOB;

      --> 두 테이블에서 같은 컬럼명, 자료형을 지닌 JOB_CODE 컬럼 기준으로
      -- JOIN이 진행된다

      /* NATURAL JOIN 실패 
      * -> 같은 컬럼명, 자료형이 없을 경우 JOIN 실패
      * 	--> 결과로 CROSS JOIN 형태가 조회된다 
      * */

      SELECT EMP_NAME, DEPT_TITLE
      FROM EMPLOYEE
      NATURAL JOIN DEPARTMENT;



     7. 다중 조인
      -- N개의 테이블을 조회할 때 사용  (순서 중요!)

      -- EMPLOYEE, DEPARTMENT, LOCATION 테이블 JOIN 하기

      -- 1) EMPLOYEE(DEPT_CODE), DEPARTMENT(DEPT_ID) JOIN
      -- 2) DEPARTMENT(LOCATION_ID), LOCATION(LOCAL_CODE) JOIN

      -- ANSI 표준

      SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
      FROM EMPLOYEE 
      JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
      JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE);


      -- 오라클 전용

      SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
      FROM EMPLOYEE, DEPARTMENT,LOCATION
      WHERE DEPT_CODE = DEPT_ID 
      AND LOCATION_ID = LOCAL_CODE;

      -- 조인 순서를 지키지 않은 경우(에러발생)

      SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
      FROM EMPLOYEE 
      JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE)
      JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

      -- ORA-00904: "LOCATION_ID": 부적합한 식별자
          --> LOCATION_ID 컬럼이 없다


   [ SUBQUERY (서브쿼리) ]

    - 하나의 SQL문 안에 포함된 또다른 SQL문
    - 메인쿼리(기존쿼리)를 위해 보조 역할을 하는 쿼리문
    -- SELECT, FROM, WHERE, HAVGIN 절에서 사용가능

    EX)
    부서코드가 노옹철사원과 같은 소속의 직원 명단 조회   
      --> 위의 2개의 단계를 하나의 쿼리로!!! --> 1) 쿼리문을 서브쿼리로!!

      SELECT EMP_NAME, DEPT_CODE
      FROM EMPLOYEE
      WHERE SALARY >= (SELECT FLOOR(AVG(SALARY)) 
                        FROM EMPLOYEE);


  - {서브쿼리 유형}

    - 단일행 서브쿼리 : 서브쿼리의 조회 결과 값의 개수가 1개일 때 
    - 다중행 서브쿼리 : 서브쿼리의 조회 결과 값의 개수가 여러개일 때
    - 다중열 서브쿼리 : 서브쿼리의 SELECT 절에 자열된 항목수가 여러개 일 때
    
    - 다중행 다중열 서브쿼리 : 조회 결과 행 수와 열 수가 여러개일 때 
    - 상관 서브쿼리 : 서브쿼리가 만든 결과 값을 메인 쿼리가 비교 연산할 때 
                     메인 쿼리 테이블의 값이 변경되면 서브쿼리의 결과값도 바뀌는 서브쿼리
                     
    - 스칼라 서브쿼리 : 상관 쿼리이면서 결과 값이 하나인 서브쿼리
    
   * 서브쿼리 유형에 따라 서브쿼리 앞에 붙은 연산자가 다름


   1. 단일행 서브쿼리 (SINGLE ROW SUBQUERY)
    --    서브쿼리의 조회 결과 값의 개수가 1개인 서브쿼리
    --    단일행 서브쿼리 앞에는 비교 연산자 사용
    --    <, >, <=, >=, =, !=/^=/<>


        /**** 서브쿼리에서 사용한 별칭을 메인 쿼리에서 사용하기 ****/
    -- 인라인뷰 : FROM 절에 사용된 서브쿼리
        --> 서브 쿼리 결과가 테이블 처럼 인식

    SELECT 이름, 급여
    FROM (SELECT EMP_NAME "이름", SALARY 급여
    FROM EMPLOYEE)
    WHERE 급여 >= 4000000;

        -- 메인쿼리 해석 1순위인 FROM절에 작성된
        -- 서브쿼리 결과 컬럼명이 "급여"
        -- 메인쿼리 해석 2순위인 WHERE
        -- 메인쿼리 해석 3순위인 SELECT절에서도
        -- 똑같이 "급여"라고 컬럼명을 작성해야한다!!


  2. 다중행 서브쿼리 (MULTI ROW SUBQUERY)
     서브쿼리의 조회 결과 값의 개수가 여러행일 때 


    >> 다중행 서브쿼리 앞에는 일반 비교연산자 사용 x
    
    - IN / NOT IN : 여러 개의 결과값 중에서 한 개라도 일치하는 값이 있다면
                    혹은 없다면 이라는 의미(가장 많이 사용!)
    - > ANY, < ANY : 여러개의 결과값 중에서 한개라도 큰 / 작은 경우
                     가장 작은 값보다 큰가? / 가장 큰 값 보다 작은가?
    - > ALL, < ALL : 여러개의 결과값의 모든 값보다 큰 / 작은 경우
                     가장 큰 값 보다 큰가? / 가장 작은 값 보다 작은가?
    - EXISTS / NOT EXISTS : 값이 존재하는가? / 존재하지 않는가?